<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BlockOfAtPositionWillBeCopiedFromNoMatterChecksum" xml:space="preserve">
    <value>ფაილის ბლოკი „{0}“ პოზიციაზე {1} კოპირებულია „{2}“-დან მაშინაც კი, თუ საკონტროლო ჯამი აჩვენებს, რომ ბლოკი არასწორია</value>
  </data>
  <data name="BlockOfAtPositionWillBeRestoredFrom" xml:space="preserve">
    <value>ფაილის ბლოკი „{0}“ პოზიციაზე {1} აღდგენილია ფაილის იგივე პოზიციიდან „{2}“.</value>
  </data>
  <data name="BlocksOfAndAtPositionNonRecoverableFillDummy" xml:space="preserve">
    <value>ფაილების „{0}“ და „{1}“ ბლოკები {2} პოზიციაზე ვერ აღდგება და შეივსება ცარიელი ბლოკით.</value>
  </data>
  <data name="ChecksumOfBlockAtOffsetNotOK" xml:space="preserve">
    <value>{0}: ბლოკის საკონტროლო ჯამი {1} პოზიციაზე არ არის კარგი</value>
  </data>
  <data name="CopiedFromToReason" xml:space="preserve">
    <value>კოპირება დასრულდა: „{0}“ „{1}“-ში {2}</value>
  </data>
  <data name="CouldntUseOutdatedFileForRestoringOther" xml:space="preserve">
    <value>გაფრთხილება: ფაილი „{0}“ 1975 წლით ან უფრო ადრე ვერ გამოიყენებოდა ფაილის „{1}“ აღსადგენად. ასეთი ძველი თარიღი მიუთითებს, რომ ეს იყო ფაილის „{0}“ აღდგენის ბოლო შანსი.</value>
  </data>
  <data name="DefaultCulture" xml:space="preserve">
    <value>No</value>
  </data>
  <data name="DeletedFileNotPresentIn" xml:space="preserve">
    <value>წაიშალა ფაილი „{0}“, რომელიც აღარ არსებობს „{1}“-ში.</value>
  </data>
  <data name="DeletedFolder" xml:space="preserve">
    <value>საქაღალდე „{0}“ შიგთავსის ჩათვლით წაშლილია, რადგან „{1}“ აღარ არსებობს</value>
  </data>
  <data name="EncounteredErrorOlderOk" xml:space="preserve">
    <value>გაფრთხილება: ფაილის „{0}“ კოპირებისას მოხდა I/O შეცდომა. როგორც ჩანს, ძველი ფაილი „{1}“ კარგად არის</value>
  </data>
  <data name="EncounteredErrorOtherBadToo" xml:space="preserve">
    <value>გაფრთხილება: ფაილის „{0}“ კოპირებისას მოხდა I/O შეცდომა. სხვა ფაილს „{1}“ ასევე აქვს შეცდომები ან არის ბოლო შანსის აღდგენის პროდუქტი. „{0}“-ის ავტომატურად შეკეთების მცდელობა.</value>
  </data>
  <data name="EncounteredErrorWhileCopyingTryingToRepair" xml:space="preserve">
    <value>გაფრთხილება: ფაილის „{0}“ კოპირებისას მოხდა შეცდომა. ვცდილობ შეცდომის გამოსწორებას.</value>
  </data>
  <data name="ErrorDeleting" xml:space="preserve">
    <value>შეცდომა ფაილის „{0}“ წაშლისას: {1}</value>
  </data>
  <data name="ErrorProcessinngFilePair" xml:space="preserve">
    <value>შეცდომა ფაილის წყვილის „{0}“ და „{1}“ დამუშავებისას: {2}</value>
  </data>
  <data name="ErrorReadingPositionWillFillWithDummy" xml:space="preserve">
    <value>შეცდომა ფაილის წაკითხვისას „{0}“ პოზიციაზე {1}: {2}. ბლოკი ივსება ნულებით</value>
  </data>
  <data name="ErrorWhileTestingFile" xml:space="preserve">
    <value>შეცდომა ფაილის „{0}“ ტესტირებისას</value>
  </data>
  <data name="FileCopied" xml:space="preserve">
    <value>კოპირება დასრულდა: „{0}“ „{1}“-ში {2}</value>
  </data>
  <data name="FileHasDifferentTime" xml:space="preserve">
    <value>(ფაილს აქვს განსხვავებული თარიღი ან სიგრძე)</value>
  </data>
  <data name="FileHasZeroLength" xml:space="preserve">
    <value>გაფრთხილება: ფაილის სიგრძე ნულოვანია, რაც მიუთითებს წარსულში წარუმატებელი კოპირების ოპერაციაზე: „{0}“</value>
  </data>
  <data name="FileHealthyOrRepaired" xml:space="preserve">
    <value>(ფაილი იყო შეცდომის გარეშე ან შეკეთდა)</value>
  </data>
  <data name="FilesHaveZeroLength" xml:space="preserve">
    <value>გაფრთხილება: ორივე ფაილის სიგრძე ნულოვანია, რაც მიუთითებს წარსულში წარუმატებელი კოპირების ოპერაციაზე: „{0}“ და „{1}“ </value>
  </data>
  <data name="FileWasHealthy" xml:space="preserve">
    <value>(ფაილი უშეცდომო იყო)</value>
  </data>
  <data name="FileWasNew" xml:space="preserve">
    <value>(ფაილი ახალი იყო)</value>
  </data>
  <data name="FileWasNewer" xml:space="preserve">
    <value>(ფაილი უფრო ახალი ან დიდი იყო)</value>
  </data>
  <data name="FillingNotRecoverableAtOffsetOfCopyWithDummy" xml:space="preserve">
    <value>კოპირებული ფაილის „{1}“ პოზიციაზე {0} ამოუხსნელი ბლოკი ივსება ნულებით</value>
  </data>
  <data name="FillingNotRecoverableAtOffsetWithDummy" xml:space="preserve">
    <value>{0} პოზიციაზე გამოუსწორებელი ბლოკი ივსება ნულებით</value>
  </data>
  <data name="FirstFileHasBadBlocks" xml:space="preserve">
    <value>გაფრთხილება: პირველ ფაილს „{0}“ აქვს ცუდი ბლოკები. ფაილის გადაწერა „{1}“ გამოტოვებულია და დარჩა სარეზერვო ასლად</value>
  </data>
  <data name="FoundFileForSync" xml:space="preserve">
    <value>ნაპოვნია ფაილი შესაძლო სინქრონიზაციისთვის</value>
  </data>
  <data name="FoundFilesForSync" xml:space="preserve">
    <value>ნაპოვნია {0} ფაილი შესაძლო სინქრონიზაციისთვის</value>
  </data>
  <data name="InternalErrorCouldntRestoreAny" xml:space="preserve">
    <value>შიდა შეცდომა: ფაილების ასლი, არც „{0}“ და არც „{1}“, ვერ აღდგება </value>
  </data>
  <data name="IOErrorDuringRepairCopyOf" xml:space="preserve">
    <value>I/O შეცდომა ფაილში ასლის შეკეთებისას: „{0}“: {1}</value>
  </data>
  <data name="IOErrorReadingFile" xml:space="preserve">
    <value>I/O შეცდომა ფაილის წაკითხვისას „{0}“: {1}</value>
  </data>
  <data name="IOErrorReadingFileOffset" xml:space="preserve">
    <value>I/O შეცდომა ფაილის წაკითხვისას: „{0}“ პოზიციაზე {1}: {2}</value>
  </data>
  <data name="IOErrorWhileReadingPositionFillDummyWhileCopy" xml:space="preserve">
    <value>I/O შეცდომა ფაილის წაკითხვისას „{0}“ მდებარეობაზე {1}: {2}. კოპირებისას ბლოკი იცვლება ცარიელი ბლოკით.</value>
  </data>
  <data name="IOErrorWritingFile" xml:space="preserve">
    <value>I/O შეცდომა ფაილის „{0}“ დაწერისას: {1}</value>
  </data>
  <data name="KeepingReadableButNotRecoverableBlockAtOffset" xml:space="preserve">
    <value>რჩება წაკითხვადი, მაგრამ არააღდგენელი ბლოკი პოზიციაზე {0}. საკონტროლო ჯამი მიუთითებს, რომ ბლოკი არასწორია</value>
  </data>
  <data name="KeepingReadableNonRecovBBlockAtAlsoInCopy" xml:space="preserve">
    <value>წაკითხვადი, მაგრამ ამოუხსნელი ბლოკი ორიგინალური ფაილის „{1}“ პოზიციაზე {0} ასევე რჩება ასლში „{2}“. საკონტროლო ჯამი მიუთითებს, რომ ბლოკი არასწორია</value>
  </data>
  <data name="LogFileName" xml:space="preserve">
    <value>დირექტორიების სინქრონიზაცია პროტოკოლი ქართული</value>
  </data>
  <data name="Message" xml:space="preserve">
    <value>კოპირების პროცესის ანგარიში</value>
  </data>
  <data name="No" xml:space="preserve">
    <value>არა</value>
  </data>
  <data name="OperationCanceled" xml:space="preserve">
    <value>პროცესი შეწყდა</value>
  </data>
  <data name="OperationFinished" xml:space="preserve">
    <value>პროცესი დასრულდა</value>
  </data>
  <data name="OutOfBadBlocksNotRestoredInCopyBytes" xml:space="preserve">
    <value>ორიგინალ ფაილში არსებული {0} ცუდი ბლოკიდან, {2} ბაიტი არ იქნა აღდგენილი ასლში „{1}“.</value>
  </data>
  <data name="ProcessNo" xml:space="preserve">
    <value>№</value>
  </data>
  <data name="RecoveringBlockAtOfCopiedFile" xml:space="preserve">
    <value>დაკოპირებული სამიზნე ფაილის „{1}“ პოზიციაზე {0} ბლოკი აღდგენილია</value>
  </data>
  <data name="RecoveringBlockAtOffsetOfFile" xml:space="preserve">
    <value>ფაილის „{1}“ პოზიციაზე {0} ბლოკი აღდგენილია.</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>no</value>
  </data>
  <data name="RunningWithoutRepairOptionUndecided" xml:space="preserve">
    <value>სინქრონიზაცია მუშაობს სარემონტო ოფციის გარეშე და, შესაბამისად, ვერ გადაწყვეტს, შესაძლებელია თუ არა ფაილის „{0}“ აღდგენა „{1}“-ის გამოყენებით.</value>
  </data>
  <data name="SavedInfoFileCantBeUsedForTesting" xml:space="preserve">
    <value>შენახული საინფორმაციო ფაილი „{0}“ არ შეიძლება გამოყენებულ იქნას ფაილის „{1}“ შესამოწმებლად: ის შეიქმნა ფაილის „{0}“ სხვა ვერსიისთვის.</value>
  </data>
  <data name="SavedInfoHasBeenDamagedNeedsRecreation" xml:space="preserve">
    <value>შენახული ინფორმაციის ფაილი „{0}“ დაზიანდა და ხელახლა უნდა შეიქმნას „{1}“-დან.</value>
  </data>
  <data name="SecondFolderNoDelete" xml:space="preserve">
    <value>შეცდომა: მეორე საქაღალდე შეიცავს ფაილს „{0}“. არჩეული საქაღალდე, როგორც ჩანს, არასწორია წაშლის ვარიანტისთვის. საქაღალდის და ქვესაქაღალდის დამუშავება გამოტოვებულია.</value>
  </data>
  <data name="SkippingFilePairDontDelete" xml:space="preserve">
    <value>ფაილების წყვილი „{0}“ და „{1}“ გამოტოვებულია. სპეციალური ფაილი ხელს უშლის წაშლის ოფციის გამოყენებას არასწორი root საქაღალდეში. </value>
  </data>
  <data name="TheFileCantBeModifiedMissingRepairApplyToCopy" xml:space="preserve">
    <value>ფაილის შეცვლა შეუძლებელია სარემონტო ვარიანტის არარსებობის გამო. აღდგენის პროცესი გამოიყენება ასლზე.</value>
  </data>
  <data name="ThereAreBadBlocksInFileNonRestorableParts" xml:space="preserve">
    <value>ფაილში „{1}“ არის {0} ცუდი ბლოკი, ამოუხსნელი ნაწილები: {2} ბაიტი.</value>
  </data>
  <data name="ThereAreBadBlocksInNonRestorableMayRetryLater" xml:space="preserve">
    <value>ფაილში „{1}“ არის {0} ცუდი ბლოკი, ამოუხსნელი ნაწილები: {2} ბაიტი. პროცესის გაგრძელება შეუძლებელია გამოუსწორებლობის გამო.  მოგვიანებით შეიძლება ხელახლა სცადოთ.</value>
  </data>
  <data name="ThereAreBadBlocksNonRestorableCantBeBackup" xml:space="preserve">
    <value>ფაილში „{1}“ არის {0} ცუდი ბლოკი, ამოუხსნელი ნაწილები: {2} ბაიტი. ფაილის სარეზერვო საშუალებად გამოყენება შეუძლებელია</value>
  </data>
  <data name="ThereAreBadBlocksNonRestorableOnlyTested" xml:space="preserve">
    <value>ფაილში „{1}“ არის {0} ცუდი ბლოკი, ამოუხსნელი ნაწილები: {2} ბაიტი. ფაილი უცვლელი რჩება, ის უბრალოდ დატესტილია</value>
  </data>
  <data name="ThereIsBadBlockInFileNonRestorableParts" xml:space="preserve">
    <value>ფაილში „{0}“ არის ცუდი ბლოკი, ამოუხსნელი ნაწილები: {1} ბაიტი.</value>
  </data>
  <data name="ThereIsBadBlockNonRestorableCantBeBackup" xml:space="preserve">
    <value>ფაილში „{0}“ არის ცუდი ბლოკი, რომლის აღდგენა შეუძლებელია: {1} ბაიტი. ფაილის სარეზერვო საშუალებად გამოყენება შეუძლებელია </value>
  </data>
  <data name="ThereIsOneBadBlockNonRestorableOnlyTested" xml:space="preserve">
    <value>ფაილში „{0}“ არის ცუდი ბლოკი, ამოუხსნელი ნაწილები: {1} ბაიტი. ფაილი უცვლელი რჩება, ის ახლახან შემოწმდა</value>
  </data>
  <data name="ThereRemainBadBlocksInBecauseReadOnly" xml:space="preserve">
    <value>{0} ცუდი ბლოკი რჩება „{1}“-ში, რადგან ფაილის შეცვლა შეუძლებელია</value>
  </data>
  <data name="ThereWasBadBlockInFileNotRestoredParts" xml:space="preserve">
    <value>ფაილში „{0}“ იყო ცუდი ბლოკი, ამოუხსნელი ნაწილები: {1} ბაიტი</value>
  </data>
  <data name="ThereWasBadBlockNotRestoredInCopyBytes" xml:space="preserve">
    <value>თავდაპირველ ფაილში იყო ცუდი ბლოკი, ამოუხსნელი ნაწილები ასლში „{0}“: {1} ბაიტი.</value>
  </data>
  <data name="ThereWereBadBlocksInFileNotRestoredParts" xml:space="preserve">
    <value>ფაილში „{1}“ იყო {0} ცუდი ბლოკი, ამოუხსნელი ნაწილები: {2} ბაიტი</value>
  </data>
  <data name="ThisIsASimulatedIOErrorAtPosition" xml:space="preserve">
    <value>ეს არის იმიტირებული I/O შეცდომა მდებარეობაზე {0}</value>
  </data>
  <data name="WarningChecksumOffsetPrimarySavedInfoIgnored" xml:space="preserve">
    <value>აფრთხილება: ბლოკის საკონტროლო ჯამი პოზიციაზე {0} არ ემთხვევა შენახული ინფორმაციის ხელმისაწვდომ ძირითად ბლოკებს „{1}“. ბლოკისთვის პირველადი შენახული ინფორმაცია იგნორირებულია</value>
  </data>
  <data name="WarningChecksumOffsetSecondarySavedInfoIgnored" xml:space="preserve">
    <value>გაფრთხილება: ბლოკის საკონტროლო ჯამი პოზიციაზე {0} არ ემთხვევა შენახული ინფორმაციის ხელმისაწვდომ მეორად ბლოკებს „{1}“. ბლოკისთვის მეორადი შენახული ინფორმაცია იგნორირებულია</value>
  </data>
  <data name="WarningCopiedToWithErrors" xml:space="preserve">
    <value>გაფრთხილება: „{0}“ დაკოპირდა „{1}“-ში შეცდომით {2} </value>
  </data>
  <data name="WarningIOErrorWhileCopyingToReason" xml:space="preserve">
    <value>გაფრთხილება: I/O შეცდომა ფაილის „{0}“ „{1}“-ზე კოპირებისას: {2}</value>
  </data>
  <data name="WarningSeveralBlocksDontMatchInSIWillBeIgnored" xml:space="preserve">
    <value>გაფრთხილება: მრავალი ბლოკი არ ემთხვევა შენახულ ინფორმაციას „{0}“. შენახული ინფორმაცია მთლიანად იგნორირებულია</value>
  </data>
  <data name="WarningWhileCreating" xml:space="preserve">
    <value>გაფრთხილება: {0} ფაილის „{1}“ შექმნისას</value>
  </data>
  <data name="WarningWhileDiscoveringIfNeedsToBeRechecked" xml:space="preserve">
    <value>გაფრთხილება: {0} იმის განსაზღვრისას, საჭიროა თუ არა „{1}“ ხელახლა შემოწმება. </value>
  </data>
  <data name="Yes" xml:space="preserve">
    <value>დიახ</value>
  </data>
</root>