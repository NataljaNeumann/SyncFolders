<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BlockOfAtPositionWillBeCopiedFromNoMatterChecksum" xml:space="preserve">
    <value>Faili "{0}" plokk asukohas {1} kopeeritakse failist "{2}" isegi siis, kui kontrollsumma näitab, et plokk on vale</value>
  </data>
  <data name="BlockOfAtPositionWillBeRestoredFrom" xml:space="preserve">
    <value>Faili "{0}" plokk asukohas {1} taastatakse faili "{2}" samast kohast.</value>
  </data>
  <data name="BlocksOfAndAtPositionNonRecoverableFillDummy" xml:space="preserve">
    <value>Failide "{0}" ja "{1}" plokke asukohas {2} ei saa taastada ja need täidetakse tühja plokiga</value>
  </data>
  <data name="ChecksumOfBlockAtOffsetNotOK" xml:space="preserve">
    <value>{0}: positsiooni {1} ploki kontrollsumma pole korras</value>
  </data>
  <data name="CopiedFromToReason" xml:space="preserve">
    <value>Kopeerimine lõpetatud: "{0}" asukohta "{1}"  {2}</value>
  </data>
  <data name="CouldntUseOutdatedFileForRestoringOther" xml:space="preserve">
    <value>Hoiatus: 1975. aasta või varasema aastaga faili "{0}" ei saanud faili "{1}" taastamiseks kasutada. Nii vana kuupäev näitab, et see oli viimane võimalus faili "{0}" taastamiseks.</value>
  </data>
  <data name="DefaultCulture" xml:space="preserve">
    <value>No</value>
  </data>
  <data name="DeletedFileNotPresentIn" xml:space="preserve">
    <value>Kustutatud fail "{0}", mida enam kaustas "{1}" ei eksisteeri.</value>
  </data>
  <data name="DeletedFolder" xml:space="preserve">
    <value>Kaust „{0}” koos sisuga kustutati, kuna „{1}” pole enam olemas</value>
  </data>
  <data name="EncounteredErrorOlderOk" xml:space="preserve">
    <value>Hoiatus: faili "{0}" kopeerimisel ilmnes I/O viga. Vanem fail "{1}" näib olevat korras</value>
  </data>
  <data name="EncounteredErrorOtherBadToo" xml:space="preserve">
    <value>Hoiatus: faili "{0}" kopeerimisel ilmnes I/O viga. Teises failis „{1}” on samuti vigu või see on viimase võimaluse taastamise toode. „{0}” automaatse parandamise katse.</value>
  </data>
  <data name="EncounteredErrorWhileCopyingTryingToRepair" xml:space="preserve">
    <value>Hoiatus: faili „{0}” kopeerimisel ilmnes viga. Proovin viga parandada.</value>
  </data>
  <data name="ErrorDeleting" xml:space="preserve">
    <value>Viga faili "{0}" kustutamisel: {1}</value>
  </data>
  <data name="ErrorProcessinngFilePair" xml:space="preserve">
    <value>Viga failipaari "{0}" ja "{1}" töötlemisel: {2}</value>
  </data>
  <data name="ErrorReadingPositionWillFillWithDummy" xml:space="preserve">
    <value>Viga faili "{0}" lugemisel asukohas {1}: {2}. Plokk on täidetud nullidega</value>
  </data>
  <data name="ErrorWhileTestingFile" xml:space="preserve">
    <value>Viga faili "{0}" testimisel</value>
  </data>
  <data name="FileCopied" xml:space="preserve">
    <value>Kopeerimine lõpetatud: "{0}" asukohta "{1}"  {2}</value>
  </data>
  <data name="FileHasDifferentTime" xml:space="preserve">
    <value>(Failil on erinev kuupäev või pikkus)</value>
  </data>
  <data name="FileHasZeroLength" xml:space="preserve">
    <value>Hoiatus: faili pikkus on null, mis näitab minevikus ebaõnnestunud kopeerimistoimingut: "{0}"</value>
  </data>
  <data name="FileHealthyOrRepaired" xml:space="preserve">
    <value>(Fail oli vigadeta või parandatud)</value>
  </data>
  <data name="FilesHaveZeroLength" xml:space="preserve">
    <value>Hoiatus: mõlema faili pikkus on null, mis näitab minevikus ebaõnnestunud kopeerimistoimingut: "{0}" ja "{1}" </value>
  </data>
  <data name="FileWasHealthy" xml:space="preserve">
    <value>(Fail oli veatu)</value>
  </data>
  <data name="FileWasNew" xml:space="preserve">
    <value>(fail oli uus)</value>
  </data>
  <data name="FileWasNewer" xml:space="preserve">
    <value>(Fail oli uuem või suurem)</value>
  </data>
  <data name="FillingNotRecoverableAtOffsetOfCopyWithDummy" xml:space="preserve">
    <value>Kopeeritud faili "{1}" positsioonil {0} asuv taastamatu plokk on täidetud nullidega</value>
  </data>
  <data name="FillingNotRecoverableAtOffsetWithDummy" xml:space="preserve">
    <value>Taastamatu plokk positsioonis {0} on täidetud nullidega</value>
  </data>
  <data name="FirstFileHasBadBlocks" xml:space="preserve">
    <value>Hoiatus: esimene fail "{0}" sisaldab vigaseid plokke. Faili "{1}" ülekirjutamine jäeti vahele, jättes selle varukoopiaks</value>
  </data>
  <data name="FoundFileForSync" xml:space="preserve">
    <value>Võimalikuks sünkroonimiseks leitud fail</value>
  </data>
  <data name="FoundFilesForSync" xml:space="preserve">
    <value>Võimalikuks sünkroonimiseks leiti {0} faili</value>
  </data>
  <data name="InternalErrorCouldntRestoreAny" xml:space="preserve">
    <value>Sisemine viga: failide koopiaid, ei "{0}" ega "{1}", ei saanud taastada </value>
  </data>
  <data name="IOErrorDuringRepairCopyOf" xml:space="preserve">
    <value>I/O viga faili koopia parandamisel: "{0}": {1}</value>
  </data>
  <data name="IOErrorReadingFile" xml:space="preserve">
    <value>I/O viga faili „{0}” lugemisel: {1}</value>
  </data>
  <data name="IOErrorReadingFileOffset" xml:space="preserve">
    <value>I/O viga faili lugemisel: „{0}” asukohas {1}: {2}</value>
  </data>
  <data name="IOErrorWhileReadingPositionFillDummyWhileCopy" xml:space="preserve">
    <value>I/O viga faili "{0}" lugemisel asukohas {1}: {2}. Plokk asendatakse kopeerimisel tühja plokiga.</value>
  </data>
  <data name="IOErrorWritingFile" xml:space="preserve">
    <value>I/O viga faili „{0}” kirjutamisel: {1}</value>
  </data>
  <data name="KeepingReadableButNotRecoverableBlockAtOffset" xml:space="preserve">
    <value>Loetav, kuid taastamatu plokk positsioonis {0} jääb alles. Kontrollsumma näitab, et plokk on vale</value>
  </data>
  <data name="KeepingReadableNonRecovBBlockAtAlsoInCopy" xml:space="preserve">
    <value>Loetav, kuid taastamatu plokk algse faili "{1}" asukohas {0} jääb samuti koopiasse "{2}". Kontrollsumma näitab, et plokk on vale</value>
  </data>
  <data name="LogFileName" xml:space="preserve">
    <value>Kataloogide sünkroniseerimise protokoll eesti keel</value>
  </data>
  <data name="Message" xml:space="preserve">
    <value>Kopeerimisprotsessi aruanne</value>
  </data>
  <data name="No" xml:space="preserve">
    <value>ei</value>
  </data>
  <data name="OperationCanceled" xml:space="preserve">
    <value>Protsess katkestati</value>
  </data>
  <data name="OperationFinished" xml:space="preserve">
    <value>Protsess lõppes</value>
  </data>
  <data name="OutOfBadBlocksNotRestoredInCopyBytes" xml:space="preserve">
    <value>Algfaili {0} vigasest plokist ei taastatud koopias "{1}" {2} baiti.</value>
  </data>
  <data name="ProcessNo" xml:space="preserve">
    <value>№</value>
  </data>
  <data name="RecoveringBlockAtOfCopiedFile" xml:space="preserve">
    <value>Kopeeritud sihtfaili „{1}” blokeerimine asukohas {0} taastatakse</value>
  </data>
  <data name="RecoveringBlockAtOffsetOfFile" xml:space="preserve">
    <value>Faili "{1}" blokeerimine asukohas {0} on taastatud.</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>no</value>
  </data>
  <data name="RunningWithoutRepairOptionUndecided" xml:space="preserve">
    <value>Sünkroonimine töötab ilma parandusvalikuta ja seetõttu ei saanud otsustada, kas faili "{0}" saab taastada "{1}" abil.</value>
  </data>
  <data name="SavedInfoFileCantBeUsedForTesting" xml:space="preserve">
    <value>Salvestatud teabefaili "{0}" ei saa kasutada faili "{1}" testimiseks: see loodi faili "{0}" teise versiooni jaoks.</value>
  </data>
  <data name="SavedInfoHasBeenDamagedNeedsRecreation" xml:space="preserve">
    <value>Salvestatud teabefail "{0}" on rikutud ja see tuleb failist "{1}" uuesti luua.</value>
  </data>
  <data name="SecondFolderNoDelete" xml:space="preserve">
    <value>Viga: teine ​​kaust sisaldab faili "{0}". Valitud kaust näib olevat kustutamisvaliku jaoks vale. Kausta ja alamkaustade töötlemine jäetakse vahele.</value>
  </data>
  <data name="SkippingFilePairDontDelete" xml:space="preserve">
    <value>Failipaar „{0}” ja „{1}” jäetakse vahele. Spetsiaalne fail takistab kustutamisvaliku kasutamist vales juurkaustas. </value>
  </data>
  <data name="TheFileCantBeModifiedMissingRepairApplyToCopy" xml:space="preserve">
    <value>Faili ei saa parandusvõimaluse puudumise tõttu muuta. Taasteprotsess rakendatakse koopiale.</value>
  </data>
  <data name="ThereAreBadBlocksInFileNonRestorableParts" xml:space="preserve">
    <value>Failis "{1}" on {0} vigast plokki, taastamatud osad: {2} baiti.</value>
  </data>
  <data name="ThereAreBadBlocksInNonRestorableMayRetryLater" xml:space="preserve">
    <value>Failis "{1}" on {0} vigast plokki, taastamatud osad: {2} baiti. Protsess ei saa taastumatuse tõttu jätkuda.  Seda võidakse hiljem uuesti proovida.</value>
  </data>
  <data name="ThereAreBadBlocksNonRestorableCantBeBackup" xml:space="preserve">
    <value>Failis "{1}" on {0} vigast plokki, taastamatud osad: {2} baiti. Faili ei saa varukoopiana kasutada</value>
  </data>
  <data name="ThereAreBadBlocksNonRestorableOnlyTested" xml:space="preserve">
    <value>Failis "{1}" on {0} vigast plokki, taastamatud osad: {2} baiti. Fail jääb muutumatuks, seda lihtsalt testiti</value>
  </data>
  <data name="ThereIsBadBlockInFileNonRestorableParts" xml:space="preserve">
    <value>Failis "{0}" on vigane plokk, taastamatud osad: {1} baiti.</value>
  </data>
  <data name="ThereIsBadBlockNonRestorableCantBeBackup" xml:space="preserve">
    <value>Failis "{0}" on vigane plokk, mida ei saa taastada: {1} baiti. Faili ei saa varukoopiana kasutada </value>
  </data>
  <data name="ThereIsOneBadBlockNonRestorableOnlyTested" xml:space="preserve">
    <value>Failis "{0}" on vigane plokk, taastamatud osad: {1} baiti. Fail jääb muutumatuks, seda lihtsalt testiti</value>
  </data>
  <data name="ThereRemainBadBlocksInBecauseReadOnly" xml:space="preserve">
    <value>{0} vigast plokki jääb kausta "{1}", kuna faili ei saa muuta</value>
  </data>
  <data name="ThereWasBadBlockInFileNotRestoredParts" xml:space="preserve">
    <value>Failis "{0}" oli vigane plokk, taastamata osad: {1} baiti</value>
  </data>
  <data name="ThereWasBadBlockNotRestoredInCopyBytes" xml:space="preserve">
    <value>Algses failis oli vigane plokk, koopias "{0}" olid taastamata osad: {1} baiti.</value>
  </data>
  <data name="ThereWereBadBlocksInFileNotRestoredParts" xml:space="preserve">
    <value>Failis "{1}" oli {0} vigast plokki, taastamata osad: {2} baiti</value>
  </data>
  <data name="ThisIsASimulatedIOErrorAtPosition" xml:space="preserve">
    <value>See on simuleeritud I/O viga asukohas {0}</value>
  </data>
  <data name="WarningChecksumOffsetPrimarySavedInfoIgnored" xml:space="preserve">
    <value>Hoiatus: positsiooni {0} ploki kontrollsumma ei ühti salvestatud teabe "{1}" saadaolevate esmaste plokkidega. Ploki esmast salvestatud teavet ignoreeritakse</value>
  </data>
  <data name="WarningChecksumOffsetSecondarySavedInfoIgnored" xml:space="preserve">
    <value>Hoiatus: positsiooni {0} ploki kontrollsumma ei ühti salvestatud teabe saadaolevate teiseste plokkidega "{1}". Ploki teisest salvestatud teavet ignoreeritakse</value>
  </data>
  <data name="WarningCopiedToWithErrors" xml:space="preserve">
    <value>Hoiatus: "{0}" kopeeriti kausta "{1}" vigadega {2} </value>
  </data>
  <data name="WarningIOErrorWhileCopyingToReason" xml:space="preserve">
    <value>Hoiatus: I/O viga faili "{0}" kopeerimisel asukohta "{1}": {2}</value>
  </data>
  <data name="WarningSeveralBlocksDontMatchInSIWillBeIgnored" xml:space="preserve">
    <value>Hoiatus: mitu plokki ei ühti salvestatud teabega "{0}". Salvestatud teavet ignoreeritakse täielikult</value>
  </data>
  <data name="WarningWhileCreating" xml:space="preserve">
    <value>Hoiatus: {0} faili "{1}" loomisel</value>
  </data>
  <data name="WarningWhileDiscoveringIfNeedsToBeRechecked" xml:space="preserve">
    <value>Hoiatus: {0} otsustades, kas "{1}" tuleb uuesti kontrollida. </value>
  </data>
  <data name="Yes" xml:space="preserve">
    <value>Jah</value>
  </data>
  <data name="DeletingObsoleteSavedInfos" xml:space="preserve">
    <value>Eemaldan vana salvestatud teabe, mis on aegunud...</value>
  </data>
  <data name="ScanningFolders" xml:space="preserve">
    <value>Otsin sünkroonimiseks kaustu ja faile...</value>
  </data>
</root>