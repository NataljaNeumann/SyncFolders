<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BlockOfAtPositionWillBeCopiedFromNoMatterChecksum" xml:space="preserve">
    <value>체크섬에서 블록이 올바르지 않음을 나타내더라도 {1} 위치에 있는 "{0}" 파일 블록이 "{2}"에서 복사되었습니다.</value>
  </data>
  <data name="BlockOfAtPositionWillBeRestoredFrom" xml:space="preserve">
    <value>{1} 위치에 있는 "{0}" 파일 블록이 "{2}" 파일의 동일한 위치에서 복원됩니다.</value>
  </data>
  <data name="BlocksOfAndAtPositionNonRecoverableFillDummy" xml:space="preserve">
    <value>{2} 위치에 있는 "{0}" 및 "{1}" 파일 블록은 복원할 수 없으며 더미 블록으로 채워져 있습니다.</value>
  </data>
  <data name="ChecksumOfBlockAtOffsetNotOK" xml:space="preserve">
    <value>{0}: {1} 위치에 있는 블록의 체크섬이 양호하지 않습니다.</value>
  </data>
  <data name="CopiedFromToReason" xml:space="preserve">
    <value>“{0}”을 “{1}”에 복사 중  {2}</value>
  </data>
  <data name="CouldntUseOutdatedFileForRestoringOther" xml:space="preserve">
    <value>경고: 1975년 이전의 파일 "{0}"을(를) 사용할 수 없습니다. 이는 이번이 "{1}" 파일을 복구할 수 있는 마지막 기회임을 나타냅니다. </value>
  </data>
  <data name="DefaultCulture" xml:space="preserve">
    <value>No</value>
  </data>
  <data name="DeletedFileNotPresentIn" xml:space="preserve">
    <value>"{1}"에 더 이상 존재하지 않는 "{0}" 파일을 삭제했습니다.</value>
  </data>
  <data name="DeletedFolder" xml:space="preserve">
    <value>"{1}"이(가) 더 이상 존재하지 않기 때문에 삭제된 콘텐츠를 포함하는 "{0}" 폴더</value>
  </data>
  <data name="EncounteredErrorOlderOk" xml:space="preserve">
    <value>경고: "{0}" 파일을 복사하는 동안 I/O 오류가 발생했습니다. 이전 파일 “{1}”은(는) 괜찮은 것 같습니다</value>
  </data>
  <data name="EncounteredErrorOtherBadToo" xml:space="preserve">
    <value>경고: "{0}" 파일을 복사하는 동안 I/O 오류가 발생했습니다. 다른 파일 “{1}”에도 오류가 있거나 최종 복구의 결과입니다. “{0}”을(를) 자동으로 복구하려고 합니다.</value>
  </data>
  <data name="EncounteredErrorWhileCopyingTryingToRepair" xml:space="preserve">
    <value>경고: "{0}" 파일을 복사하는 동안 오류가 발생했습니다. 오류를 수정하도록 노력하겠습니다.</value>
  </data>
  <data name="ErrorDeleting" xml:space="preserve">
    <value>"{0}" 파일 삭제 오류: {1}</value>
  </data>
  <data name="ErrorProcessinngFilePair" xml:space="preserve">
    <value>파일 쌍 "{0}" 처리 중 오류 발생 | “{1}”: {2}</value>
  </data>
  <data name="ErrorReadingPositionWillFillWithDummy" xml:space="preserve">
    <value>{1} 위치에서 "{0}" 파일을 읽는 동안 오류가 발생했습니다: {2}. 블록은 더미로 채워집니다.</value>
  </data>
  <data name="ErrorWhileTestingFile" xml:space="preserve">
    <value>파일 "{0}" 테스트 중 오류 발생</value>
  </data>
  <data name="FileCopied" xml:space="preserve">
    <value>“{0}”을 “{1}”에 복사 중  {2}</value>
  </data>
  <data name="FileHasDifferentTime" xml:space="preserve">
    <value>(파일의 날짜나 길이가 다릅니다)</value>
  </data>
  <data name="FileHasZeroLength" xml:space="preserve">
    <value>경고: 파일 길이가 0입니다. 이는 과거에 복사 작업이 실패했음을 나타냅니다: "{0}" </value>
  </data>
  <data name="FileHealthyOrRepaired" xml:space="preserve">
    <value>(파일에 오류가 없거나 복구되었습니다)</value>
  </data>
  <data name="FilesHaveZeroLength" xml:space="preserve">
    <value>경고: 두 파일 모두 길이가 0입니다. 이는 과거에 실패한 복사 작업을 나타냅니다. "{0}" | "{1}" </value>
  </data>
  <data name="FileWasHealthy" xml:space="preserve">
    <value>(파일에 오류가 없었습니다)</value>
  </data>
  <data name="FileWasNew" xml:space="preserve">
    <value>(파일은 새로운 것이었습니다)</value>
  </data>
  <data name="FileWasNewer" xml:space="preserve">
    <value>(파일이 더 최신이거나 더 컸습니다)</value>
  </data>
  <data name="FillingNotRecoverableAtOffsetOfCopyWithDummy" xml:space="preserve">
    <value>복사된 파일 "{1}"의 {0} 위치에 있는 복구 불가능한 블록이 더미로 채워져 있습니다.</value>
  </data>
  <data name="FillingNotRecoverableAtOffsetWithDummy" xml:space="preserve">
    <value>{0} 위치의 복구 불가능한 블록이 더미 블록으로 채워져 있습니다.</value>
  </data>
  <data name="FirstFileHasBadBlocks" xml:space="preserve">
    <value>경고: 첫 번째 파일 "{0}"에 잘못된 블록이 있습니다. 파일 "{1}" 덮어쓰기를 건너뛰어 백업으로 남겨두었습니다.</value>
  </data>
  <data name="FoundFileForSync" xml:space="preserve">
    <value>동기화할 수 있는 파일을 찾았습니다</value>
  </data>
  <data name="FoundFilesForSync" xml:space="preserve">
    <value>동기화 가능한 파일 {0}개를 찾았습니다. </value>
  </data>
  <data name="InternalErrorCouldntRestoreAny" xml:space="preserve">
    <value>내부 오류: "{0}" | "{1}" 파일의 복사본을 복원할 수 없습니다. </value>
  </data>
  <data name="IOErrorDuringRepairCopyOf" xml:space="preserve">
    <value>파일 복사를 복구하는 중 I/O 오류: "{0}": {1}</value>
  </data>
  <data name="IOErrorReadingFile" xml:space="preserve">
    <value>"{0}" 파일을 읽는 동안 I/O 오류가 발생했습니다: {1}</value>
  </data>
  <data name="IOErrorReadingFileOffset" xml:space="preserve">
    <value>파일 읽기 중 I/O 오류 발생: 위치 {1}의 “{0}”: {2}</value>
  </data>
  <data name="IOErrorWhileReadingPositionFillDummyWhileCopy" xml:space="preserve">
    <value>{1} 위치에서 "{0}" 파일을 읽는 동안 I/O 오류가 발생했습니다: {2}. 블록은 복사될 때 더미로 대체됩니다.</value>
  </data>
  <data name="IOErrorWritingFile" xml:space="preserve">
    <value>“{0}” 파일을 쓰는 중 I/O 오류 발생: {1}</value>
  </data>
  <data name="KeepingReadableButNotRecoverableBlockAtOffset" xml:space="preserve">
    <value>읽을 수는 있지만 복구할 수 없는 {0} 위치의 블록이 남아 있습니다. 체크섬은 블록이 잘못되었음을 나타냅니다.</value>
  </data>
  <data name="KeepingReadableNonRecovBBlockAtAlsoInCopy" xml:space="preserve">
    <value>원본 파일 "{1}"의 {0} 위치에 있는 읽기 가능하지만 복구할 수 없는 블록도 복사본 "{2}"에 남아 있습니다. 체크섬은 블록이 잘못되었음을 나타냅니다.</value>
  </data>
  <data name="LogFileName" xml:space="preserve">
    <value>디렉터리 동기화 로그 한국어</value>
  </data>
  <data name="Message" xml:space="preserve">
    <value>복사 과정 보고서</value>
  </data>
  <data name="No" xml:space="preserve">
    <value>아니요 </value>
  </data>
  <data name="OperationCanceled" xml:space="preserve">
    <value>프로세스가 중단되었습니다.</value>
  </data>
  <data name="OperationFinished" xml:space="preserve">
    <value>프로세스가 종료되었습니다.</value>
  </data>
  <data name="OutOfBadBlocksNotRestoredInCopyBytes" xml:space="preserve">
    <value>원본 파일의 불량 블록 {0}개 중 {2}바이트가 "{1}" 복사본에서 복구되지 않았습니다.</value>
  </data>
  <data name="ProcessNo" xml:space="preserve">
    <value>No</value>
  </data>
  <data name="RecoveringBlockAtOfCopiedFile" xml:space="preserve">
    <value>복사된 대상 파일 “{1}”의 {0} 위치에 있는 블록이 복원되었습니다.</value>
  </data>
  <data name="RecoveringBlockAtOffsetOfFile" xml:space="preserve">
    <value>"{1}" 파일의 {0} 위치에 있는 블록이 복원되었습니다.</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>no</value>
  </data>
  <data name="RunningWithoutRepairOptionUndecided" xml:space="preserve">
    <value>복구 옵션 없이 동기화가 실행 중이므로 "{0}" 파일을 "{1}"을(를) 사용하여 복원할 수 있는지 여부를 결정할 수 없습니다.</value>
  </data>
  <data name="SavedInfoFileCantBeUsedForTesting" xml:space="preserve">
    <value>저장된 정보 파일 "{0}"을(를) 사용하여 "{1}" 파일을 테스트할 수 없습니다. 파일의 다른 버전용으로 생성되었습니다.</value>
  </data>
  <data name="SavedInfoHasBeenDamagedNeedsRecreation" xml:space="preserve">
    <value>저장된 정보 파일 “{0}”이(가) 손상되어 “{1}”에서 다시 생성해야 합니다.</value>
  </data>
  <data name="SecondFolderNoDelete" xml:space="preserve">
    <value>오류: 두 번째 폴더에 "{0}" 파일이 포함되어 있습니다. 선택한 폴더가 삭제 옵션에 적합하지 않은 것 같습니다. 폴더 및 하위 폴더 처리 건너뛰기</value>
  </data>
  <data name="SkippingFilePairDontDelete" xml:space="preserve">
    <value>파일 쌍 “{0}” | “{1}”을(를) 건너뛰었습니다. 특수 파일은 잘못된 루트 폴더에서 삭제 옵션을 사용하는 것을 방지합니다. </value>
  </data>
  <data name="TheFileCantBeModifiedMissingRepairApplyToCopy" xml:space="preserve">
    <value>복구 옵션이 없어 파일을 수정할 수 없습니다. 복구 프로세스가 복사본에 적용됩니다.</value>
  </data>
  <data name="ThereAreBadBlocksInFileNonRestorableParts" xml:space="preserve">
    <value>"{1}" 파일에 불량 블록이 {0}개 있습니다. 복구할 수 없는 부분은 {2}바이트입니다.</value>
  </data>
  <data name="ThereAreBadBlocksInNonRestorableMayRetryLater" xml:space="preserve">
    <value>"{1}" 파일에 불량 블록이 {0}개 있습니다. 복구할 수 없는 부분은 {2}바이트입니다. 복구 불가능으로 인해 프로세스를 계속할 수 없습니다.  나중에 다시 시도할 수 있습니다.</value>
  </data>
  <data name="ThereAreBadBlocksNonRestorableCantBeBackup" xml:space="preserve">
    <value>"{1}" 파일에 불량 블록이 {0}개 있습니다. 복구할 수 없는 부분: {2}바이트, 파일을 백업으로 사용할 수 없습니다.</value>
  </data>
  <data name="ThereAreBadBlocksNonRestorableOnlyTested" xml:space="preserve">
    <value>"{1}" 파일에 불량 블록이 {0}개 있습니다. 복구할 수 없는 부분은 {2}바이트입니다. 파일은 변경되지 않은 상태로 유지되며 방금 테스트되었습니다.</value>
  </data>
  <data name="ThereIsBadBlockInFileNonRestorableParts" xml:space="preserve">
    <value>파일 "{0}"에 불량 블록이 있습니다. 복구할 수 없는 부분: {1}바이트.</value>
  </data>
  <data name="ThereIsBadBlockNonRestorableCantBeBackup" xml:space="preserve">
    <value>"{0}" 파일에 복원할 수 없는 불량 블록이 있습니다. {1}바이트, 파일을 백업으로 사용할 수 없습니다.</value>
  </data>
  <data name="ThereIsOneBadBlockNonRestorableOnlyTested" xml:space="preserve">
    <value>"{0}" 파일에 불량 블록이 있습니다. 복구할 수 없는 부분: {1}바이트, 파일은 변경되지 않고 그대로 유지되며 방금 테스트되었습니다.</value>
  </data>
  <data name="ThereRemainBadBlocksInBecauseReadOnly" xml:space="preserve">
    <value>파일을 수정할 수 없기 때문에 {0}개의 불량 블록이 "{1}"에 남아 있습니다.</value>
  </data>
  <data name="ThereWasBadBlockInFileNotRestoredPartsThereWasBadBlockInFileNotRestoredParts" xml:space="preserve">
    <value>"{0}" 파일에 불량 블록이 있습니다. 복구되지 않은 부분: {1}바이트</value>
  </data>
  <data name="ThereWasBadBlockNotRestoredInCopyBytes" xml:space="preserve">
    <value>원본 파일에 불량 블록이 있습니다. 복사본 "{0}"에 복구되지 않은 부분이 있습니다: {1}바이트.</value>
  </data>
  <data name="ThereWereBadBlocksInFileNotRestoredParts" xml:space="preserve">
    <value>"{1}" 파일에 불량 블록이 {0}개 있습니다. 복구되지 않은 부분: {2}바이트</value>
  </data>
  <data name="ThisIsASimulatedIOErrorAtPosition" xml:space="preserve">
    <value>이는 {0} 위치에서 시뮬레이션된 I/O 오류입니다.</value>
  </data>
  <data name="WarningChecksumOffsetPrimarySavedInfoIgnored" xml:space="preserve">
    <value>경고: {0} 위치에 있는 블록의 체크섬이 저장된 정보 "{1}"의 사용 가능한 기본 블록과 일치하지 않습니다. 블록에 대한 기본 저장된 정보는 무시됩니다.</value>
  </data>
  <data name="WarningChecksumOffsetSecondarySavedInfoIgnored" xml:space="preserve">
    <value>경고: {0} 위치에 있는 블록의 체크섬이 저장된 정보 "{1}"의 사용 가능한 보조 블록과 일치하지 않습니다. 블록에 대한 2차 저장 정보는 무시됩니다.</value>
  </data>
  <data name="WarningCopiedToWithErrors" xml:space="preserve">
    <value>경고: “{0}”이(가) 오류 {2}와 함께 “{1}”에 복사되었습니다. </value>
  </data>
  <data name="WarningIOErrorWhileCopyingToReason" xml:space="preserve">
    <value>경고: "{0}" 파일을 "{1}"에 복사하는 중 I/O 오류: {2}</value>
  </data>
  <data name="WarningSeveralBlocksDontMatchInSIWillBeIgnored" xml:space="preserve">
    <value>경고: 여러 블록이 저장된 정보 "{0}"과(와) 일치하지 않습니다. 저장된 정보는 완전히 무시됩니다.</value>
  </data>
  <data name="WarningWhileCreating" xml:space="preserve">
    <value>경고: "{1}" 파일을 생성하는 중 {0}</value>
  </data>
  <data name="WarningWhileDiscoveringIfNeedsToBeRechecked" xml:space="preserve">
    <value>경고: "{1}"을(를) 다시 확인해야 하는지 여부를 결정하는 동안 {0}입니다. </value>
  </data>
  <data name="Yes" xml:space="preserve">
    <value>예</value>
  </data>
</root>